\chapter{Benchmark und Bewertung}
\label{chapter:Dokumentation-BenchmarkBewertung}

\section{Berechnung}
\label{section:Dokumentation-BenchmarkBewertung-Berechnung}

Für die Berechnung der Laufzeit und für die Bewertung des Algorithmus gelten folgende Vorschriften:

\subsection{Variablen}
\label{subsection:Dokumentation-BenchmarkBewertung-Berechnung-Variablen}

\begin{description}
    \item[reg] Anzahl der ergänzten Minimaxregister
    \item[se] Anzahl der ergänzten Sign"=Extension"=Units (0 oder 1)
    \item[const] Anzahl der ergänzten Konstanten (eine "`0"' und eine "`1"' frei)
    \item[alu\_add] Penaltysumme für alle ergänzten ALU"=Befehle
    \item[alu\_use] Penaltysumme der \emph{verwendeten} ALU"=Befehle im Programm
\end{description}

\begin{center}
    \begin{tabular}{|@{\hspace{2pt}}c@{\hspace{2pt}}||@{\hspace{2pt}}c@{\hspace{2pt}}|@{\hspace{2pt}}c@{\hspace{2pt}}|@{\hspace{2pt}}c@{\hspace{2pt}}|@{\hspace{2pt}}c@{\hspace{2pt}}|@{\hspace{2pt}}c@{\hspace{2pt}}|@{\hspace{2pt}}c@{\hspace{2pt}}|@{\hspace{2pt}}c@{\hspace{2pt}}|}
        \hline
        extra ALU"=Op. & SUB1 & INC/DEC & S.L, S.R & AND, OR, NOT & XOR & DIV & Custom \\ 
        \hline
        Penalty (1..20) & 1 & 4 & 5 & 6 & 8 & 10 & bis zu 20 \\
        \hline
    \end{tabular}
\end{center}

\subsubsection{Variablenwerte}
\label{subsubsection:Dokumentation-BenchmarkBewertung-Berechnung-Variablen-Variablenwerte}

\todo{Werte bestimmen, einsetzen und berechnen}

Im Folgenden sind die Werte für den verwendeten Algoritmus angegeben:

\begin{align*}
    reg      &= 7 \\
    se       &= 0 \\
    const    &= 8 \\
    alu\_add &= 10 + 10 + 6 = 26 \\
    alu\_use &= 10 + 10 + 6 = 26
\end{align*}

\subsection{Laufzeit}
\label{subsection:Dokumentation-BenchmarkBewertung-Berechnung-Laufzeit}

Die Laufzeit des Algorithmus wird in Minimaxtakten gezählt und berechnet sich nach folgender Formel:

\begin{align*}
    t_{bewertet} &= t_{bench} \cdot (1 + 0.1 \cdot reg + 0.15 \cdot se + 0.015 \cdot alu\_add + 0.05 \cdot const) \\
                 &= t_{bench} \cdot (1 + 0.1 \cdot 7 + 0.15 \cdot 0 + 0.015 \cdot 26 + 0.05 \cdot 8) \\
                 &= t_{bench} \cdot 2.49
\end{align*}

Zur Bestimmung von $t_{bench}$ wurden 3 Speicherabbilder mit jeweils 1120 Bytes zur Verfügung gestellt:

\begin{enumerate}
    \item Alle Pakete haben eine Länge von 80 Bits (Pakete ohne Daten)
    \item Durchschnittliche Datenteillänge von 80 Bits
    \item Durchschnittliche Datenteillänge von 144 Bits
\end{enumerate}

Nach Simulation des Algorithmus mit allen drei Beispielen wurden folgende Ergebnisse festgestellt: \todo{berechnen}

\begin{center}
    \begin{tabular}{|l|l|l|}
        \hline
        Speicherabbild & Minimaxtakte & $t_{bewertet}$ \\
        \hline
        \hline
        1 & 2000 & 4000 \\
        \hline
        2 & 2000 & 4000 \\
        \hline
        3 & 2000 & 4000 \\
        \hline
    \end{tabular}
\end{center}

\subsection{Länge}
\label{subsection:Dokumentation-BenchmarkBewertung-Berechnung-Laenge}

Die Länge des Algorithmus berechnet sich nach folgender Formel:

\begin{align*}
    n_{bewertet} &= n_{Algorithmus} + 5 \cdot reg + 10 \cdot se + 3 \cdot alu\_use + 5 \cdot const \\
                 &= xxx + 5 \cdot 7 + 10 \cdot 0 + 3 \cdot 26 + 5 \cdot 8 \\
                 &= xxx + 153
\end{align*}

\section{Abschließende Bewertung}
\label{section:Dokumentation-BenchmarkBewertung-Bewertung}

Dieser Algorithmus überzeugt hauptsächlich durch den einfachen Zugriff auf das Ergebnis. Da der Hauptspeicher unbegrenzt ist, stellt der große Bruttospeicherbedarf keinen allzu großen Nachteil dar. Die Laufzeit des Algorithmus ist der Aufgabe angemessen, kann mit einer definierteren Struktur der Daten aber noch optimiert werden. Die umfangreichen Hardwareerweiterungen erfordern eine ausreichend hohe Auflagengröße, da nicht vollständig auf Standardkomponenten zurückgegriffen werden kann. Für kleinere Stückzahlen findet sich eventuell eine umfangreichere Basismaschine, wodurch die Kosten eventuell reduziert werden können.

\section{Probleme bei der Durchführung}
\label{section:Dokumentation-BenchmarkBewertung-Probleme}

Während der Entwicklung nahm die Implementierung für den Simulator die meiste Zeit in Anspruch. Das Verhalten war mehrfach unerwartet und undokumentiert. Fehlermeldungen bestanden i.d.R. lediglich aus Stacktraces, welche ohne den Quelltext jedoch weitgehend nutzlos waren. Hier sind Fehler aufgelistet, auf die wir gestoßen sind.

\begin{itemize}
    \item Multiplikation produziert Overflows und schneidet nicht einfach ab
    \item Strings in der GUI sind nicht ausgeschrieben
    \item Multiplexer A kann nur bis 12 rechnen (trotz theoretischer 4 Bit)
    \item Multiplexer B kann nur bis 9 rechnen (trotz theoretischer 4 Bit)
    \item if geht nur mit else
    \item Leitungen lassen sich nicht teilen
    \item Fehlermeldungen unbrauchbar, da kein Quelltext vorhanden ist
\end{itemize}
